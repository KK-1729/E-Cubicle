{
  "_args": [
    [
      {
        "raw": "sift@13.5.2",
        "scope": null,
        "escapedName": "sift",
        "name": "sift",
        "rawSpec": "13.5.2",
        "spec": "13.5.2",
        "type": "version"
      },
      "C:\\Users\\Me\\Desktop\\ToDoList-master\\node_modules\\mongoose"
    ]
  ],
  "_from": "sift@13.5.2",
  "_hasShrinkwrap": false,
  "_id": "sift@13.5.2",
  "_location": "/sift",
  "_nodeVersion": "14.16.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/sift_13.5.2_1619165764759_0.49366017219889735"
  },
  "_npmUser": {
    "name": "crcn",
    "email": "craig.j.condon@gmail.com"
  },
  "_npmVersion": "6.14.11",
  "_phantomChildren": {},
  "_requested": {
    "raw": "sift@13.5.2",
    "scope": null,
    "escapedName": "sift",
    "name": "sift",
    "rawSpec": "13.5.2",
    "spec": "13.5.2",
    "type": "version"
  },
  "_requiredBy": [
    "/mongoose"
  ],
  "_resolved": "https://registry.npmjs.org/sift/-/sift-13.5.2.tgz",
  "_shasum": "24a715e13c617b086166cd04917d204a591c9da6",
  "_shrinkwrap": null,
  "_spec": "sift@13.5.2",
  "_where": "C:\\Users\\Me\\Desktop\\ToDoList-master\\node_modules\\mongoose",
  "author": {
    "name": "Craig Condon",
    "email": "craig.j.condon@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/crcn/sift.js/issues"
  },
  "dependencies": {},
  "description": "MongoDB query filtering in JavaScript",
  "devDependencies": {
    "@rollup/plugin-replace": "^2.3.2",
    "@rollup/plugin-typescript": "^4.1.1",
    "@types/node": "^13.7.0",
    "bson": "^4.0.3",
    "eval": "^0.1.4",
    "husky": "^1.2.1",
    "immutable": "^3.7.6",
    "mocha": "8.3.2",
    "mongodb": "^3.6.6",
    "prettier": "1.15.3",
    "pretty-quick": "^1.11.1",
    "rimraf": "^3.0.2",
    "rollup": "^2.7.2",
    "rollup-plugin-terser": "^7.0.2",
    "tslib": "^2.0.0",
    "typescript": "^3.8.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-+gxdEOMA2J+AI+fVsCqeNn7Tgx3M9ZN9jdi95939l1IJ8cZsqS8sqpJyOkic2SJk+1+98Uwryt/gL6XDaV+UZA==",
    "shasum": "24a715e13c617b086166cd04917d204a591c9da6",
    "tarball": "https://registry.npmjs.org/sift/-/sift-13.5.2.tgz",
    "fileCount": 20,
    "unpackedSize": 267024,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJggoJFCRA9TVsSAnZWagAAnAMP/iAvH346d4cFSo1uOLwv\nXcd6gNrIlI0OCfjM4NpsTcvNW6doZ+3rXllyX1OzWzGgr51lDySGJsla7q3K\nPKlaahUfzyCf5x1qQ7uCdWuvseZ4YhcbTbDMiNyZEC1Ul3eO426M4DrFB+bu\n5C3yi+CXM53ZF8uylwfdjKG7AvftLXUOuKOsKlJ00DlSuqUVQc2Y0SIcN/9L\nVgJ+QujSzRw/oDfgZoCAfI8LiAAEfvLFWMV1NK8SEe2HHkQXrofbEA4xjLl6\nqmLNBQ94ZkE+LmRIgVGzyWhck1qfsJ6AZWV6pnfRuYdKYKl2cq3MTi50oG4S\nEsh+Rgf5Pqg2kYgvuJ1sv3j7SoDDYzOV3wSZ23oSdZQWt++f8b3xBLsE5p4/\nguHXWSCahp2MXbvegydphSwHLFfSyDJo4fXuRHVdZ0Pw4Ts7+TX3eI4mtat7\nwppGqEyhHG4jQEX88zGCoY8GOhg6YWWgXQSBdAj3EP6kgUnZo98MW5mQhLO5\nu8gBIjYC3aoFGArregAKVwxzPrPlE4GqNHvo8Hs2XryZE55lkIVANiAemgmc\n9Bjo3gqt9SZMT4VogT2ring8VQ2DwieGpSlR6EnRJEv7dvjxI1PKAz1WZ4lf\nylw1AeTa1UcF/Gz2WuBupxqtK8D6b+ZxQ3A3hS+k+a8m57VNWQyqi7gX3voM\nIso2\r\n=Z1dt\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {},
  "es2015": "./es/index.js",
  "files": [
    "es",
    "es5m",
    "lib",
    "*.d.ts",
    "*.js.map",
    "index.js",
    "sift.csp.min.js",
    "sift.min.js",
    "MIT-LICENSE.txt"
  ],
  "gitHead": "fca2592c118076f99929b0c24b6a3d37015ffec4",
  "homepage": "https://github.com/crcn/sift.js#readme",
  "husky": {
    "hooks": {
      "pre-commit": "pretty-quick --staged"
    }
  },
  "license": "MIT",
  "main": "./index.js",
  "maintainers": [
    {
      "name": "architectd",
      "email": "craig.j.condon@gmail.com"
    },
    {
      "name": "crcn",
      "email": "craig.j.condon@gmail.com"
    }
  ],
  "module": "./es5m/index.js",
  "name": "sift",
  "optionalDependencies": {},
  "readme": "**Installation**: `npm install sift`, or `yarn add sift`\n\n## Sift is a tiny library for using MongoDB queries in Javascript\n\n[![Build Status](https://secure.travis-ci.org/crcn/sift.js.png)](https://secure.travis-ci.org/crcn/sift.js)\n\n<!-- [![Coverage Status](https://coveralls.io/repos/crcn/sift.js/badge.svg)](https://coveralls.io/r/crcn/sift.js)  -->\n<!-- [![Join the chat at https://gitter.im/crcn/sift.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crcn/sift.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) -->\n\n**For extended documentation, checkout http://docs.mongodb.org/manual/reference/operator/query/**\n\n## Features:\n\n- Supported operators: [\\$in](#in), [\\$nin](#nin), [\\$exists](#exists), [\\$gte](#gte), [\\$gt](#gt), [\\$lte](#lte), [\\$lt](#lt), [\\$eq](#eq), [\\$ne](#ne), [\\$mod](#mod), [\\$all](#all), [\\$and](#and), [\\$or](#or), [\\$nor](#nor), [\\$not](#not), [\\$size](#size), [\\$type](#type), [\\$regex](#regex), [\\$where](#where), [\\$elemMatch](#elemmatch)\n- Regexp searches\n- Supports node.js, and web\n- Custom Operations\n- Tree-shaking (omitting functionality from web app bundles)\n\n## Examples\n\n```javascript\nimport sift from \"sift\";\n\n//intersecting arrays\nconst result1 = [\"hello\", \"sifted\", \"array!\"].filter(\n  sift({ $in: [\"hello\", \"world\"] })\n); //['hello']\n\n//regexp filter\nconst result2 = [\"craig\", \"john\", \"jake\"].filter(sift(/^j/)); //['john','jake']\n\n// function filter\nconst testFilter = sift({\n  //you can also filter against functions\n  name: function(value) {\n    return value.length == 5;\n  }\n});\n\nconst result3 = [\n  {\n    name: \"craig\"\n  },\n  {\n    name: \"john\"\n  },\n  {\n    name: \"jake\"\n  }\n].filter(testFilter); // filtered: [{ name: 'craig' }]\n\n//you can test *single values* against your custom sifter\ntestFilter({ name: \"sarah\" }); //true\ntestFilter({ name: \"tim\" }); //false\n```\n\n## API\n\n### sift(query: MongoQuery, options?: Options): Function\n\nCreates a filter with all of the built-in MongoDB query operations.\n\n- `query` - the filter to use against the target array\n- `options`\n  - `operations` - [custom operations](#custom-operations)\n  - `compare` - compares difference between two values\n\nExample:\n\n```javascript\nimport sift from \"sift\";\n\nconst test = sift({ $gt: 5 }));\n\nconsole.log(test(6)); // true\nconsole.log(test(4)); // false\n\n[3, 4, 5, 6, 7].filter(sift({ $exists: true })); // [6, 7]\n```\n\n### createQueryTester(query: Query, options?: Options): Function\n\nCreates a filter function **without** built-in MongoDB query operations. This is useful\nif you're looking to omit certain operations from application bundles. See [Omitting built-in operations](#omitting-built-in-operations) for more info.\n\n```javascript\nimport { createQueryTester, $eq, $in } from \"sift\";\nconst filter = createQueryTester({ $eq: 5 }, { operations: { $eq, $in } });\n```\n\n### createEqualsOperation(params: any, ownerQuery: Query, options: Options): Operation\n\nUsed for [custom operations](#custom-operations).\n\n```javascript\nimport { createQueryTester, createEqualsOperation, $eq, $in } from \"sift\";\nconst filter = createQueryTester(\n  { $mod: 5 },\n  {\n    operations: {\n      $something(mod, ownerQuery, options) {\n        return createEqualsOperation(\n          value => value % mod === 0,\n          ownerQuery,\n          options\n        );\n      }\n    }\n  }\n);\nfilter(10); // true\nfilter(11); // false\n```\n\n## Supported Operators\n\nSee MongoDB's [advanced queries](http://www.mongodb.org/display/DOCS/Advanced+Queries) for more info.\n\n### \\$in\n\narray value must be _\\$in_ the given query:\n\nIntersecting two arrays:\n\n```javascript\n//filtered: ['Brazil']\n[\"Brazil\", \"Haiti\", \"Peru\", \"Chile\"].filter(\n  sift({ $in: [\"Costa Rica\", \"Brazil\"] })\n);\n```\n\nHere's another example. This acts more like the \\$or operator:\n\n```javascript\n[{ name: \"Craig\", location: \"Brazil\" }].filter(\n  sift({ location: { $in: [\"Costa Rica\", \"Brazil\"] } })\n);\n```\n\n### \\$nin\n\nOpposite of \\$in:\n\n```javascript\n//filtered: ['Haiti','Peru','Chile']\n[\"Brazil\", \"Haiti\", \"Peru\", \"Chile\"].filter(\n  sift({ $nin: [\"Costa Rica\", \"Brazil\"] })\n);\n```\n\n### \\$exists\n\nChecks if whether a value exists:\n\n```javascript\n//filtered: ['Craig','Tim']\nsift({ $exists: true })([\"Craig\", null, \"Tim\"]);\n```\n\nYou can also filter out values that don't exist\n\n```javascript\n//filtered: [{ name: \"Tim\" }]\n[{ name: \"Craig\", city: \"Minneapolis\" }, { name: \"Tim\" }].filter(\n  sift({ city: { $exists: false } })\n);\n```\n\n### \\$gte\n\nChecks if a number is >= value:\n\n```javascript\n//filtered: [2, 3]\n[0, 1, 2, 3].filter(sift({ $gte: 2 }));\n```\n\n### \\$gt\n\nChecks if a number is > value:\n\n```javascript\n//filtered: [3]\n[0, 1, 2, 3].filter(sift({ $gt: 2 }));\n```\n\n### \\$lte\n\nChecks if a number is <= value.\n\n```javascript\n//filtered: [0, 1, 2]\n[0, 1, 2, 3].filter(sift({ $lte: 2 }));\n```\n\n### \\$lt\n\nChecks if number is < value.\n\n```javascript\n//filtered: [0, 1]\n[0, 1, 2, 3].filter(sift({ $lt: 2 }));\n```\n\n### \\$eq\n\nChecks if `query === value`. Note that **\\$eq can be omitted**. For **\\$eq**, and **\\$ne**\n\n```javascript\n//filtered: [{ state: 'MN' }]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: { $eq: \"MN\" } })\n);\n```\n\nOr:\n\n```javascript\n//filtered: [{ state: 'MN' }]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: \"MN\" })\n);\n```\n\n### \\$ne\n\nChecks if `query !== value`.\n\n```javascript\n//filtered: [{ state: 'CA' }, { state: 'WI'}]\n[{ state: \"MN\" }, { state: \"CA\" }, { state: \"WI\" }].filter(\n  sift({ state: { $ne: \"MN\" } })\n);\n```\n\n### \\$mod\n\nModulus:\n\n```javascript\n//filtered: [300, 600]\n[100, 200, 300, 400, 500, 600].filter(sift({ $mod: [3, 0] }));\n```\n\n### \\$all\n\nvalues must match **everything** in array:\n\n```javascript\n//filtered: [ { tags: ['books','programming','travel' ]} ]\n[\n  { tags: [\"books\", \"programming\", \"travel\"] },\n  { tags: [\"travel\", \"cooking\"] }\n].filter(sift({ tags: { $all: [\"books\", \"programming\"] } }));\n```\n\n### \\$and\n\nability to use an array of expressions. All expressions must test true.\n\n```javascript\n//filtered: [ { name: 'Craig', state: 'MN' }]\n\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $and: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$or\n\nOR array of expressions.\n\n```javascript\n//filtered: [ { name: 'Craig', state: 'MN' }, { name: 'Tim', state: 'MN' }]\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $or: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$nor\n\nopposite of or:\n\n```javascript\n//filtered: [ { name: 'Tim', state: 'MN' }, { name: 'Joe', state: 'CA' }]\n[\n  { name: \"Craig\", state: \"MN\" },\n  { name: \"Tim\", state: \"MN\" },\n  { name: \"Joe\", state: \"CA\" }\n].filter(sift({ $nor: [{ name: \"Craig\" }, { state: \"MN\" }] }));\n```\n\n### \\$size\n\nMatches an array - must match given size:\n\n```javascript\n//filtered: ['food','cooking']\n[{ tags: [\"food\", \"cooking\"] }, { tags: [\"traveling\"] }].filter(\n  sift({ tags: { $size: 2 } })\n);\n```\n\n### \\$type\n\nMatches a values based on the type\n\n```javascript\n[new Date(), 4342, \"hello world\"].filter(sift({ $type: Date })); //returns single date\n[new Date(), 4342, \"hello world\"].filter(sift({ $type: String })); //returns ['hello world']\n```\n\n### \\$regex\n\nMatches values based on the given regular expression\n\n```javascript\n[\"frank\", \"fred\", \"sam\", \"frost\"].filter(\n  sift({ $regex: /^f/i, $nin: [\"frank\"] })\n); // [\"fred\", \"frost\"]\n[\"frank\", \"fred\", \"sam\", \"frost\"].filter(\n  sift({ $regex: \"^f\", $options: \"i\", $nin: [\"frank\"] })\n); // [\"fred\", \"frost\"]\n```\n\n### \\$where\n\nMatches based on some javascript comparison\n\n```javascript\n[{ name: \"frank\" }, { name: \"joe\" }].filter(\n  sift({ $where: \"this.name === 'frank'\" })\n); // [\"frank\"]\n[{ name: \"frank\" }, { name: \"joe\" }].filter(\n  sift({\n    $where: function() {\n      return this.name === \"frank\";\n    }\n  })\n); // [\"frank\"]\n```\n\n### \\$elemMatch\n\nMatches elements of array\n\n```javascript\nvar bills = [\n  {\n    month: \"july\",\n    casts: [\n      {\n        id: 1,\n        value: 200\n      },\n      {\n        id: 2,\n        value: 1000\n      }\n    ]\n  },\n  {\n    month: \"august\",\n    casts: [\n      {\n        id: 3,\n        value: 1000\n      },\n      {\n        id: 4,\n        value: 4000\n      }\n    ]\n  }\n];\n\nvar result = bills.filter(\n  sift({\n    casts: {\n      $elemMatch: {\n        value: { $gt: 1000 }\n      }\n    }\n  })\n); // {month:'august', casts:[{id:3, value: 1000},{id: 4, value: 4000}]}\n```\n\n### \\$not\n\nNot expression:\n\n```javascript\n[\"craig\", \"tim\", \"jake\"].filter(sift({ $not: { $in: [\"craig\", \"tim\"] } })); //['jake']\n[\"craig\", \"tim\", \"jake\"].filter(sift({ $not: { $size: 5 } })); //['tim','jake']\n```\n\n### Date comparison\n\nMongodb allows you to do date comparisons like so:\n\n```javascript\ndb.collection.find({ createdAt: { $gte: \"2018-03-22T06:00:00Z\" } });\n```\n\nIn Sift, you'll need to specify a Date object:\n\n```javascript\ncollection.find(\n  sift({ createdAt: { $gte: new Date(\"2018-03-22T06:00:00Z\") } })\n);\n```\n\n## Custom behavior\n\nSift works like MongoDB out of the box, but you're also able to modify the behavior to suite your needs.\n\n#### Custom operations\n\nYou can register your own custom operations. Here's an example:\n\n```javascript\nimport sift, { createEqualsOperation } from \"sift\";\n\nvar filter = sift(\n  {\n    $customMod: 2\n  },\n  {\n    operations: {\n      $customMod(params, ownerQuery, options) {\n        return createEqualsOperation(\n          value => value % params !== 0,\n          ownerQuery,\n          options\n        );\n      }\n    }\n  }\n);\n\n[1, 2, 3, 4, 5].filter(filter); // 1, 3, 5\n```\n\n#### Omitting built-in operations\n\nYou can create a filter function that omits the built-in operations like so:\n\n```javascript\nimport { createQueryTester, $in, $all, $nin, $lt } from \"sift\";\nconst test = createQueryTester(\n  {\n    $eq: 10\n  },\n  { $in, $all, $nin, $lt }\n);\n\n[1, 2, 3, 4, 10].filter(test);\n```\n\nFor bundlers like `Webpack` and `Rollup`, operations that aren't used are omitted from application bundles via tree-shaking.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/crcn/sift.js.git"
  },
  "scripts": {
    "build": "rollup -c",
    "build:types": "tsc -p tsconfig.json --emitDeclarationOnly --outDir lib",
    "clean": "rimraf lib es5m es",
    "prebuild": "npm run clean && npm run build:types",
    "prepublishOnly": "npm run build && npm run test",
    "test": "npm run test:spec && npm run test:types",
    "test:spec": "mocha ./test -R spec",
    "test:types": "cd test && tsc types.ts --noEmit"
  },
  "sideEffects": false,
  "typings": "./index.d.ts",
  "version": "13.5.2"
}
